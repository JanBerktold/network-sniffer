/*
	Application parses the output file generated by sniffer.c, decodes the layer 3 and 4
	of the OSI model and writes its result to a SQL database for further analysis.
*/
package main

import (
	"bufio"
	"compress/gzip"
	"encoding/binary"
	"flag"
	"fmt"
	"os"
)

var (
	file                 *os.File
	name                 string
	dataConnectionString string
	verbose              bool
)

func init() {
	flag.StringVar(&name, "file", "output", "File to parse")
	flag.StringVar(&dataConnectionString, "db", "", "String to connect to the target SQL database")
	flag.BoolVar(&verbose, "v", true, "whether to print while uploading")
	flag.Parse()

	if lFile, err := os.Open(name); err == nil {
		file = lFile
	} else {
		fmt.Printf("Failed to open file with error %q\n", err.Error())
		os.Exit(-1)
	}

	if len(dataConnectionString) > 0 {
		initConnection()
	}
}

func formatMac(b []byte) string {
	return fmt.Sprintf(
		"%x::%x::%x::%x::%x::%x",
		b[0], b[1], b[2], b[3], b[4], b[5],
	)
}

func formatIP(a uint32) string {
	return fmt.Sprintf("%d.%d.%d.%d", byte(a>>24), byte(a>>16), byte(a>>8), byte(a))
}

// TODO(Jan Berktold): Implement FragmentOffset
func main() {
	gReader, err := gzip.NewReader(file)
	if err != nil {
		fmt.Printf("Failed error while opening file: %q\n", err.Error())
	}
	reader := bufio.NewReader(gReader)

	ethHead := EthernetHeader{
		Destination: make([]byte, 6),
		Source:      make([]byte, 6),
	}

	var packLen uint32
	var count int

	for {
		count++

		if err := binary.Read(reader, binary.LittleEndian, &packLen); err != nil {
			fmt.Println("Reached end")
			break
		}

		if verbose {
			fmt.Printf("\t-- Total Length: %v --\n", packLen)
		}

		reader.Read(ethHead.Destination)
		reader.Read(ethHead.Source)
		binary.Read(reader, binary.BigEndian, &ethHead.Type)

		if verbose {
			fmt.Printf("\t-- Layer 2 :: Ethernet Header --\n")
			fmt.Printf("\t\tDestination: %v\n", formatMac(ethHead.Destination))
			fmt.Printf("\t\tSource: %v\n", formatMac(ethHead.Source))
			fmt.Printf("\t\tType: %#X\n", ethHead.Type)
		}

		level3Header := parser3[ethHead.Type](reader)

		fmt.Println(level3Header)

		otherData := make([]byte, packLen-14-1-6-2-2-2-4-3)
		reader.Read(otherData)

		if count == 50 {
			break
		}
	}
}
